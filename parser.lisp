(in-package :clisprolog)

(let ((oprank-list nil))
  (defun parser (terms)
    (iterate (for op in *op-defs*)
             (let ((entry (assoc (rank op) oprank-list)))
               (setf oprank-list
                     (cons (cons (rank op) (cons op (cdr entry)))
                           (delete-if (lambda (x) (= (car x) (rank op)))
                                      oprank-list)))))
    (setf oprank-list (sort oprank-list #'> :key #'car))
    (print oprank-list)
    (main-parser terms))
  (defun main-parser (terms)
    (if (null terms) nil
        (multiple-value-bind (ast rest)
            (sub-parser oprank-list terms)
          (if-not (eq (type-of (car rest)) 'prolog-period)
                  (error "parse-error ~A" (prolog-value-str (car rest)))
                  (progn (dump-ast ast)
                         (cons ast (main-parser (cdr rest)))))))))

(defun sub-parser (opdef-list terms)
  (if (null opdef-list)
      (if (and (not (null terms))
               (operand-p (car terms)))
          (values (car terms) (cdr terms))
          (values nil terms))
      (multiple-value-bind (arg1 rest)
          (sub-parser (cdr opdef-list) terms)
        (cond ((or (null rest)
                   (operand-p (car rest)))
               (error "parse-error"))
              ((eq (type-of (car rest)) 'prolog-period)
               (values arg1 rest))
              ((eq (type-of (car rest)) 'prolog-op)
               (match-op opdef-list rest arg1))
              (t (error "parse-error"))))))

(defun match-op (opdef-list terms arg1)
  (let ((next-term (name (car terms))))
    (multiple-value-bind (xarg2 xrest)
        (sub-parser (cdr opdef-list) (cdr terms))
      (multiple-value-bind (yarg2 yrest)
          (sub-parser opdef-list (cdr terms))                       
        (labels
            ((rec (op-list)
               (if (null op-list)
                   (values arg1 terms)
                   (let ((op-name (name (car op-list)))
                         (op-assoc (assoc-type (car op-list))))
                     (if-not
                      (string= next-term op-name)
                      (rec (cdr op-list))
                      (cond ((eq op-assoc :fx)
                             (if (and (null arg1) (not (null xarg2)))
                                 (values (list (car op-list) xarg2)
                                         xrest)
                                 (rec (cdr op-list))))
                            ((eq op-assoc :fy)
                             (if (and (null arg1) (not (null yarg2)))
                                 (values (list (car op-list) yarg2)
                                         yrest)
                                 (rec (cdr op-list))))
                            ((find op-assoc '(:xf :yf) :test #'eq)
                             (if (and (not (null arg1))
                                      (null xarg2) (null yarg2))
                                 (values (list (car op-list) arg1)
                                         (cdr terms))))
                            ((eq op-assoc :xfx)
                             (if (and (not (null arg1)) (not (null xarg2)))
                                 (values (list (car op-list) arg1 xarg2)
                                         xrest)
                                 (rec (cdr op-list))))
                            ((find op-assoc '(:xfy :yfx) :test #'eq)
                             (if (and (not (null arg1)) (not (null yarg2)))
                                 (values (if (eq op-assoc :yfx)
                                             (adjust-lassoc
                                              (list (car op-list) arg1 yarg2))
                                             (list (car op-list) arg1 yarg2))
                                         yrest)
                                 (rec (cdr op-list))))))))))
          (rec (cdar opdef-list)))))))

(defun adjust-lassoc (ast)
  (assert (listp ast))
  (assert (eq (assoc-type (first ast)) :yfx))
  (let ((op (first ast))
        (lchild (second ast))
        (rchild (third ast)))
    (if-not (and (listp rchild)
                 (= (rank op) (rank (first rchild)))               
                 (eq (assoc-type (first rchild)) :yfx))
            ast (list (first rchild)
                      (adjust-lassoc (list op lchild (second rchild)))
                      (third rchild)))))

(defun dump-ast (ast &optional (depth 0))
  (cond ((listp ast)
         (dump-ast (car ast) depth)
         (mapc (lambda (x) (dump-ast x (1+ depth))) (cdr ast))
         nil)
        (t (iterate (repeat depth) (format t " "))
           (format t "~A~%" (prolog-value-str ast))
           nil)))

(defun parse-test (path)
  (mapc (lambda (ast) (dump-ast ast))
        (parser (reader (lexer path) :global)))
  nil)
