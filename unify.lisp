(in-package :clisprolog)

(defun instanced-p (arg)
  (find (type-of arg) '(prolog-atom prolog-num)))

(defun apply-bind (ast bind)
  (cond ((listp ast)
         (mapcar (lambda (x) (apply-bind x bind)) ast))
        ((eq (type-of ast) 'prolog-pred)
         (make-instance 'prolog-pred
                        :name (name ast)
                        :args (mapcar (lambda (x) (apply-bind x bind))
                                      (args ast))))
        ((eq (type-of ast) 'prolog-var)
         (get-bind-value ast bind))
        (t ast)))

(defun get-bind-value (var bind)
  (let ((value
         (cdr (assoc (intern (name var) 'keyword)
                     bind))))
    (cond ((null value) var)
          ((eq (type-of value) 'prolog-var)
           (get-bind-value value bind))
          (t value))))

(defun unify (arg1 arg2)
  (cond ((and (eq (type-of arg1) 'prolog-var)
              (eq (type-of arg2) 'prolog-var))
         (values (list (cons (intern (name arg1) 'keyword)
                             arg2))
                 t))
        ((and (instanced-p arg1)
              (eq (type-of arg2) 'prolog-var))
         (values (list (cons (intern (name arg2) 'keyword)
                             arg1))
                 t))
        ((and (eq (type-of arg1) 'prolog-var)
              (instanced-p arg2))
         (values (list (cons (intern (name arg1) 'keyword)
                             arg2))
                 t))
        ((and (instanced-p arg1) (instanced-p arg2))
         (if-not (eq (type-of arg1) (type-of arg2))
                 (values nil nil)
                 (case (type-of arg1)
                   (prolog-atom
                    (values nil (string= (value arg1)
                                         (value arg2))))
                   (prolog-num
                    (values nil (= (value arg1)
                                   (value arg2)))))))
          ((and (eq (type-of arg1) 'prolog-pred)
                (eq (type-of arg2) 'prolog-pred))
           (if-not (= (length (args arg1))
                      (length (args arg2)))
                   (values nil nil)
                   (unify-arg (args arg1) (args arg2))))))


(defun unify-arg (args1 args2 &optional (bind nil))
  (assert (= (length args1) (length args2)))
  (if (null args1)
      (values bind t)
      (let ((arg1 (apply-bind (car args1) bind))
            (arg2 (apply-bind (car args2) bind)))
        (multiple-value-bind (new-bind res)
            (unify arg1 arg2)
          (if res
              (unify-arg (cdr args1) (cdr args2)
                         (append new-bind bind))
              (values nil nil))))))
